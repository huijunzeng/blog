### 基于本地消息的最终一致性方案demo  rabbitmq消息生产方（即上游服务）
***
这里展示的demo为distributed-transaction-rabbitmq-producer服务创建account用户账号的时候，调用distributed-transaction-rabbitmq-consumer下游服务同时创建相对应的一条points积分记录；因为上下游通过mq消息异步通信的，所以是无感知的，也就是说上游事务成功后发送消息到mq，下游监听到消息后进行消费需要确保不出现业务上的异常，否则回滚上游事务比较困难（需要进行补偿事务操作）

基于本地消息，所以需要在上游服务创建一张记录事务提交消息的数据表，以便于mq发送消息失败时的check回检机制

基于本地消息的最终一致性方案的最核心做法就是在执行业务操作的时候，记录一条消息数据到DB，并且消息数据的记录与业务数据的记录必须在同一个事务内完成，这是该方案的前提核心保障。在记录完成后消息数据后，后面我们就可以通过一个定时任务到DB中去轮训状态为待发送的消息（或者利用Spring特有的事务同步器TransactionSynchronization在提交完事务后发送mq消息），然后将消息投递给MQ。这个过程中可能存在消息投递失败的可能，此时就依靠重试机制来保证，直到成功收到MQ的ACK确认之后，再将消息状态更新或者消息清除；而后面消息的消费失败的话，则依赖MQ本身的重试来完成，其最后做到两边系统数据的最终一致性。基于本地消息服务的方案虽然可以做到消息的最终一致性，但是它有一个比较严重的弊端，每个业务系统在使用该方案时，都需要在对应的业务库创建一张消息表来存储消息。
